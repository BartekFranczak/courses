---
number: 5
course: Informatyka I
material: Instrukcja 5
author: "W. Regulski"
---

```{r, echo = FALSE}
set.seed(14) # Set seed for all the pictures to be reproducible
```

# Tablice
Celem dzisiejszych zajęć jest wprowadzenie do tablic w języku C.
Tablicą (ang. *array*) nazywamy ciąg zmiennych tego samego typu, które zajmują kolejne komórki pamięci.
Aby dostać się do zadanego elementu, używamy nazwy tablicy i indeksu identyfikującego element.
Na tych zajęciach zajmiemy się tablicami statycznymi, tzn. takimi, których rozmiar jest określany w momencie deklaracji^[bardziej zaawansowany mechanizm alokacji tablic będzie tematem następnych zajęć].
Tablicę statyczną deklarujemy tak jak zwykłą zmienną, przy czym dodatkowo określamy jej długość (czyli liczbę elementów).
Przykładowo:

```c++
  double a[4];     // deklaracja tablicy

  a[0] = 5.5;      // definicja - przypisanie wartosci do zmiennych
  a[1] = 3.521;
  a[2] = 6.45;
  a[3] = 4.51;

```
Zwróć uwagę, że elementy tablicy sa indeksowane liczbami od $0$ do $N - 1$, gdzie $N$ to rozmiar tablicy.
Elementy tablicy można również zainicjalizować natychmiast -- w momencie deklaracji:
```c++
  double b[3] = {1.2, 2.4, -4.3};  // wartosci zawarte w nawiasach "{" i "}" definiuja tablice
  double c[5] = {0};               // wszystkie elementy tablicy zostana uzupelnione zerami
```

# Gra w kulki
Zadanie polegać będzie na:

- wygenerowaniu w oknie graficznym zestawu małych piłeczek,
- wprawieniu ich w ruch,
- implementacji zasad kolizji ze ścianami oraz
- implementacji wzajamnych zderzeń piłeczek. 

Przykładowy ekran początkowy widoczny jest na Rysunku 1 (strzałki zaznaczono poglądowo).
```{r, echo = FALSE}
n = 5
p = matrix(runif(n * 2), n, 2)
v = matrix(runif(n * 2), n, 2) / 5
plot(p, xlim = c(0, 1), ylim = c(0, 1), xlab = "X", ylab = "Y", asp = 1, cex  = 3)
arrows(p[, 1], p[, 2], (p + v)[, 1], (p + v)[, 2])
lines(cbind(c(0, 0, 1, 1, 0), c(0, 1, 1, 0, 0)))
```

Nasze piłki przychowywane będą jako zestawy współrzędnych $(x, y)$ oraz prędkości $(xV, yV)$.
Oznacza to, że będą potrzebne następujące tablice:
```c++ 
double x[10], y[10];        // wspolrzedne pilek
double xV[10], yV[10];      // skladowe predkosci pilek
```
Gdy będziemy chcieli obejrzeć piłki w oknie graficznym, użyjemy funkcji `circle()`, podając jako argumenty numery elementów tablic.
Przykładowo:
```c++ 
circle(x[0], y[0], 5);
```

## Pętla `for`

Większość operacji będziemy wykonywać, używając funkcji, które będą przyjmować wprowadzone wyżej tablice jako argumenty.
Funkcje będą musiały także pobierać długość tablic tak, aby pewne operacje można było wykonać dla każdego z jej elementów.
Jeśli chcemy np. zainicjalizować wszystkie współrzędne wartością $0$, napiszemy funkcję:
```c++
void init(double *x, double *y, int N) {
  int i;
  
  for (i = 0; i < N; i++) {
    x[i] = 0.0;
    y[i] = 0.0;
  }
}
```

Wykorzystaliśmy tutaj pętlę `for`, która pobiera $3$ argumenty:

- wartość startową licznika $i = 0$,
- warunek stopu (pętla działa, dopóki $i < N$ ),
- operację na liczniku (tutaj zwiększamy $i$ o $1$, co będzie najpowszechniejszą praktyką^[Teoretycznie możemy w tym miejscu wykonać dowolną operację, jednak dla czytelności kodu zazwyczaj zwiększamy licznik pętli]).

Taką funkcję wywołujemy w programie głównym, podając nazwy tablic, na których ma działać oraz ich długość:
```c++
  init(x, y, 10);
```

Czytelnik zauważy, że funkcja `init` pobiera dwa wskaźniki do tablic (u nas do tablicy `x` oraz `y`).
Oznacza to, że w momencie wywołania funkcja oczekuje podania adresów tych tablic.
My podaliśmy jedynie ich nazwy (`x` i `y`) -- wynika stąd, że nazwa tablicy jest jednocześnie jej adresem.

Warto podkreślić, że wykorzystanie wskaźnika to jedyny sposób przekazania tablicy do funkcji.
Tablicy nie da się przekazać przez wartość, tak jak w przypadku ,,zwykłych zmiennych'' (`int`, `double`, itd.).

## Uwaga
Ponieważ `x` oraz `y` są wskaźnikami do pierwszych elementów tablic, można wykorzystać mechanizm działań na wskaźnikach.
Poniższy fragment kodu pokazuje dwa równoważne sposoby dostępu do wartości z tablicy:

```c++
double a[3];

a[0] = 1.2;       // inicjalizacja klasyczna z wykorzystaniem "[" i "]"
a[1] = 3.13;
a[2] = 0.22;

*(a + 0) = 1.2;  // inicjalizacja z wykorzstaniem wskaznikow
*(a + 1) = 3.13;
*(a + 2) = 0.22;
```

## Ćwiczenia
Przed wykonaniem ćwiczeń upewnij się, że dołączono bibliotekę `winbgi2.h` -- będziemy korzystać z grafiki.

- Zadeklaruj wymienione wyżej tablice (`x`, `y`, `xV` i `yV`) o długości $10$.
- Otwórz okno graficzne o wymiarach $L_x \times L_y = 400 \times 400$.
- Napisz funkcję `init`, która losuje położenia początkowe kulek tak, aby kółka mieściły się one w oknie graficznym.
Użyj funkcji `rand()` z biblioteki `stdlib.h` (patrz zajęcia $4$).
- Napisz funkcję `display`, która wyświetli położenie kółek (funkcja powina mieć tę samą strukturę, co funkcja \verb|init|).


# Ruch

Oczywiście piłeczki mają się poruszać, zatem konieczne będzie określenie wartości prędkości początkowych oraz zaprogramowanie ruchu piłeczek.


## Ćwiczenia

- Napisz funkcję, która wylosuje początkowe prędkości piłek. Wylosuj je tak, aby wartość prędkości wynosiła 1 
   (najłatwiej będzie wylosować dowolną liczbę i jej sinus i cosinus przypisać jako składowe prędkości piłki)
- Napisz funkcję \verb|run|, która będzie wykonwać przesunięcie każdej z piłek. Przemieszczenie będzie po prostu polegać na zwiększeniu każdej współrzędnej o składową prędkość^[piłki poruszają się ze stałą prędkością, toteż $x(t+\Delta t) = x(t) + v\Delta t $, a dla uproszczenia symulacji czas jest jednostkowy zatem $x(t+1) = x(t) + v$]:

```c++
     for ( i=0; i < N; ++i){
          x[i] += cx[i];
          y[i] += cy[i];
     }
```

- W głównym programie napisz pętlę \verb|while|, która wykona 50 kroków iteracji programu. Niech przy każdym kroku wyświetla położenie każdej piłki. W ciele pętli użyj funkcji \verb|animate(100)| - spowolni ona wykonywanie kolejnych kroków pętli. Jej użycie wyglądało następująco.

```c++
while(animate(100)) {
   clear(); // wyczysci okno graficzne dla nowej klatki
   // Dalsza czesc ciala petli
}
```


# Kolizje ze ścianami
Chcielibyśmy, aby piłeczki miały wbudowany jakiś mechanizm kolizji ze ścianami. 
Zderzenia będą doskonale sprężyste, kąt padania na przeszkodę będzie zatem równy kątowi odbicia od niej. Kąty mierzone względem normalnej do ściany.

## Ćwiczenia
- Do funkcji \verb|run| dopisz warunek, który sprawdza, czy piłka zderzyła się ze ścianą. W przypadku kolizji należy zastosować prawo odbicia, które będzie miało prostą formę:
Jeśli uderzamy w ścianę poziomą, wystarczy zmienić składową prędkości $cy$ na przeciwną. Analogicznie przy kolizji ze ścianą pionową, zmieniamy składową $cx$ na przeciwną.
Sprawdź, jak działa program np. dla 5000 kroków.
- Napisz funkcję `showEnergy`, która będzie wyświetlała na ekranie wartość całkowitej energii kinetycznej układu.



# Kolizje z piłkami

Dopisz funkcję `searchAndCollide`, która sprawdza, czy piłki zderzają się ze sobą nawzajem.
Trzeba będzie przeiterować się po wszystkich współrzędnych sąsiadów i sprawdzić, czy odległość piłek jest dostatecznie mała.
Weźmy dwie kulki 1 i 2 o prędkościach przed zderzeniem odpowiednio $v_{1}$ i $v_{2}$ oraz położeniach $p_{1}$ i $p_{2}$.
Przyjmijmy, że kulki mają te same masy. Z zasady zachowania pędu wynika, że prędkości po zderzeniu będą wynosić:
$$
\hat v_{1}= v_{1}+\Delta v
$$
$$
\hat v_{2}= v_{2}-\Delta v
$$
gdzie $\Delta v$ to pęd którym wymieniły się kulki. Jedyny kierunek w którym następuje wymiana pędem (zakładamy tu brak tarcia) to kierunek prostopadły do płaszczyzny zderzenia:
$$\Delta v=C(p_{1}-p_{2})$$
Teraz wystarczy jedynie spełnić zasadę zachowania energii. Znów przyjmując równe masy otrzymujemy:
$$\newcommand{\abs}[1]{\left|#1\right|}\abs{v_1}^2+\abs{v_2}^2 = \abs{\hat v_1}^2 + \abs{\hat v_2}^2$$
$$0 = 2\abs{\Delta v}^2 + 2\Delta v\cdot (v_1-v_2)$$
$$0 = C^2\abs{p_{1}-p_{2}}^2 + C(p_{1}-p_{2})\cdot (v_1-v_2)$$
$$C = - \frac{(p_{1}-p_{2})\cdot (v_1-v_2)}{\abs{p_{1}-p_{2}}^2}$$
Warto zauważyć, że znak iloczynu skalarnego $(p_{1}-p_{2})\cdot (v_1-v_2)$ mówi nam czy kulki lecą do siebie czy od siebie. Ostatecznie można powiedzieć że zderzenie następuje tylko gdy $C>0$.

```{R echo=FALSE}
plot(NA,xlim=c(-2,4),ylim=c(-1,2),asp=1,axes = FALSE,xlab="",ylab="")
a = seq(0,2*pi,len=100)
p = 2*c(cos(0.3),sin(0.3))
v1 = c(-0.5,1.2)
v2 = c(0.5,1.6)
lines(cos(a),sin(a))
lines(cos(a)+p[1],sin(a)+p[2])
arrows2 = function(...) arrows(...,angle=15)
arrows2(0,0,p[1],p[2],lty=2)
text(0,0,labels = expression(p[2]),lwd=2,adj=c(-.2,1))
text(p[1],p[2],labels = expression(p[1]),lwd=2,adj=c(-.2,1))
text(p[1]/3,p[2]/3,labels = expression(p[1]-p[2]),lwd=2,adj=c(-.2,1))
text(p[1]/3,p[2]/3,labels = expression(p[1]-p[2]),lwd=2,adj=c(-.2,1))
arrows2(0,0,v2[1],v2[2],lwd=2)
text(v2[1]/2,v2[2]/2,labels = expression(v[2]),lwd=2,adj=c(-.2,1))
arrows2(p[1],p[2],p[1]+v1[1],p[2]+v1[2],lwd=2)
text(p[1]+v1[1]/2,p[2]+v1[2]/2,labels = expression(v[1]),lwd=2,adj=c(1.2,1))
C = -sum((v1-v2)*p)/sum(p*p)
arrows2(v2[1],v2[2],v2[1]-C*p[1],v2[2]-C*p[2])
text(v2[1]-C*p[1]/2,v2[2]-C*p[2]/2,labels = expression(Delta*v),lwd=2,adj=c(.5,-0.2))
arrows2(p[1]+v1[1],p[2]+v1[2],p[1]+v1[1]+C*p[1],p[2]+v1[2]+C*p[2])
text(p[1]+v1[1]+C*p[1]/2,p[2]+v1[2]+C*p[2]/2,labels = expression(Delta*v),lwd=2,adj=c(.5,-0.2))
v1=v1+C*p
v2=v2-C*p
arrows2(0,0,v2[1],v2[2])
arrows2(p[1],p[2],p[1]+v1[1],p[2]+v1[2])
```
